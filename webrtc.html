<html lang="en">

<head>
  <meta charset="utf-8" http-equiv="Content-Language" content="en" />
  <meta name="description" content="WebRTC code samples">
  <meta name="viewport" content="width=device-width, user-scalable=yes, initial-scale=1, maximum-scale=1">
  <meta itemprop="description" content="Client-side WebRTC code samples">
  <meta itemprop="name" content="WebRTC code samples">
  <meta name="mobile-web-app-capable" content="yes">
  <meta id="theme-color" name="theme-color" content="#ffffff">

  <title>GStreamer webrtc camera</title>
  <script src="https://webrtc.github.io/adapter/adapter-latest.js"></script>

  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/css/bootstrap.min.css" rel="stylesheet"
    crossorigin="anonymous">

  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.2.3/dist/js/bootstrap.bundle.min.js"
    crossorigin="anonymous"></script>
  <script src="https://unpkg.com/vconsole@latest/dist/vconsole.min.js"></script>
  <script>
    'use strict';
    var websocketConnection;
    var webrtcPeerConnection;
    var localpc;
    var localdc;
    var reportError;
    var startWatch;
    var startRecord;
    var enableTalk;

    var isRecord = false;
    var isTalk = false;
    var vConsole = new window.VConsole();
    const turn_config = {
      'iceServers': [{
        urls: 'turn:192.168.1.100:3478',
        username: "test",
        credential: "test123"
      }]
    };

    const stun_config = {
      'iceServers': [{
        urls: 'turn:stunserver.stunprotocol.org:3478'
      }]
    };

    function onIceCandidate(event) {
      if (event.candidate == null)
        return;

      // console.log("Sending ICE candidate out: " + JSON.stringify(event.candidate));
      websocketConnection.send(JSON.stringify({ "type": "ice", "data": event.candidate }));
    }

    function reportError(err) {
      console.error(err);
    }

    function createSender(stream) {
      console.log("stream: " + JSON.stringify(stream));
      localpc = new RTCPeerConnection(turn_config);
      localdc = localpc.createDataChannel("web page channel");

      localdc.onmessage = (event) => {
        console.log(`received: ${event.data}`);
        // pc.close(); // We decided to close after the first received message
      };

      localdc.onopen = () => {
        console.log("datachannel open");
      };

      localdc.onclose = () => {
        console.log("datachannel close");
      };

      stream.getTracks().forEach(function (track) {
        console.log("add track.");
        localpc.addTrack(track);
      });


      localpc.createOffer().then(d => {
        localpc.setLocalDescription(d);
        console.log("Send offer to remote: " + d);
        websocketConnection.send(JSON.stringify({ type: "sdp", "data": d }));
      }).catch((err) => {
        console.log(" crete offer err: " + err);
      });
      localpc.oniceconnectionstatechange = e => console.log(localpc.iceConnectionState)
      localpc.onicecandidate = onIceCandidate;
      localpc.onsignalingstatechange = (ev) => {
        switch (localpc.signalingState) {
          case "stable":
            console.log("ICE negotiation complete");
            break;
        }
      };
    }

    // buttons control
    window.onload = function () {
      startWatch = document.getElementById('startWatch');
      startRecord = document.getElementById('startRecord');
      enableTalk = document.getElementById('enableTalk');

      startRecord.disabled = true;
      enableTalk.disabled = true;

      startWatch.addEventListener('click', (event) => {
        console.log("start watch webrtc!!!");
        document.getElementById('loading').style['display'] = "block";
        startWatch.disabled = true;
        startWatch.classList.remove('btn-info');
        startWatch.classList.add('btn-light');
        // On firefox browser needed set media.peerconnection.use_document_iceservers = false
        // media.peerconnection.turn.disable = false

        webrtcPeerConnection = new RTCPeerConnection(turn_config);
        webrtcPeerConnection.ontrack = onAddRemoteStream;
        webrtcPeerConnection.onicecandidate = onIceCandidate;
        webrtcPeerConnection.addTransceiver('video', { 'direction': 'sendrecv' });
        webrtcPeerConnection.addTransceiver('audio', { 'direction': 'sendrecv' });
        playStream(null, null, null);

        startRecord.addEventListener('click', (event) => {
          event.preventDefault();
          console.log(startRecord.innerHTML + " on remote !!! " + isRecord);
          isRecord = !isRecord;

          startRecord.innerHTML = isRecord ? "Stop Record" : "Start Record";
          if (websocketConnection != undefined) {
            websocketConnection.send(JSON.stringify({ "type": "cmd", "cmd": "record", "arg": isRecord ? "start" : "stop" }));
          }

        });
        enableTalk.addEventListener('click', (event) => {
          console.log("enable talks now!!!");
          if (isTalk) {

            localpc.getTransceivers().forEach((transceiver) => {
              console.log("stop track.");
              transceiver.stop();
            });
            localpc.getSenders().forEach((sender) => {
              console.log("remove track.");
              localpc.removeTrack(sender);
            });
            localdc.send(JSON.stringify({ "type": "cmd", "cmd": "talk", "arg": "stop" }));
            localpc.close();
          } else {
            // enableTalk.disabled = true;
            // To get navigator.mediaDevices, https should be enabled if not opened on localhost.
            navigator.mediaDevices.getUserMedia({
              audio: true,
              video: {
                width: { min: 800, ideal: 1280, max: 1920 },
                height: { min: 600, ideal: 720, max: 1080 },
              }
            }).then((stream) => {
              createSender(stream);
            }).catch((err) => {
              console.log("Capture media error: " + err);
            });
          }
          isTalk = !isTalk
          enableTalk.innerHTML = isTalk ? "Talk off" : "Talk on";
          event.preventDefault();
        });
        event.preventDefault();
      });
    }


    // recvonly webrtc
    function onLocalDescription(desc) {
      // console.log("Local description: " + JSON.stringify(desc));
      webrtcPeerConnection.setLocalDescription(desc).then(function () {
        websocketConnection.send(JSON.stringify({ type: "sdp", "data": webrtcPeerConnection.localDescription }));
      }).catch(reportError);
    }


    function onIncomingSDP(sdp) {
      // console.log("Incoming SDP: " + JSON.stringify(sdp));
      if (sdp.type === "offer") {
        webrtcPeerConnection.setRemoteDescription(sdp).catch(reportError);
        webrtcPeerConnection.createAnswer().then(onLocalDescription).catch(reportError);
      } else {
        // console.log("answser Sdp: " + sdp.sdp);
        localpc.setRemoteDescription(sdp).catch(reportError);
      }
    }


    function onIncomingICE(ice) {
      var candidate = new RTCIceCandidate(ice);
      if (startRecord.disabled == false && localpc) {
        // console.log("answer Incoming ICE: " + JSON.stringify(ice));
        localpc.addIceCandidate(candidate).catch(reportError);
      } else {
        webrtcPeerConnection.addIceCandidate(candidate).catch(reportError);
      }
    }

    function recordCallBack(data) {
      // alert("Recording thread is already running!!!");
      isRecord = false;
      startRecord.innerHTML = isRecord ? "Stop Record" : "Start Record";
    }

    function onAddRemoteStream(event) {
      // var el = document.createElement(event.track.kind)
      const el = document.getElementById('video0');
      el.srcObject = event.streams[0]
      el.autoplay = true
      el.controls = true

      // enable other two buttons
      startRecord.disabled = false;
      startRecord.classList.remove('btn-light');
      startRecord.classList.add('btn-info');

      enableTalk.disabled = false;
      enableTalk.classList.remove('btn-light');
      enableTalk.classList.add('btn-info');
      document.getElementById('loading').style['display'] = "none";
    }

    function onServerMessage(event) {
      var msg;

      try {
        msg = JSON.parse(event.data);
      } catch (e) {
        console.log("parse json error: " + e);
        return;
      }

      if (msg.record)
        return recordCallBack(msg.record);


      switch (msg.type) {
        case "sdp": onIncomingSDP(msg.data); break;
        case "ice": onIncomingICE(msg.data); break;
        default: break;
      }
    }


    function playStream(hostname, port, path) {
      var l = window.location;
      var wsHost = (hostname != undefined) ? hostname : l.hostname;
      var wsPort = (port != undefined) ? port : l.port;
      var wsPath = (path != undefined) ? path : "ws";
      if (wsPort)
        wsPort = ":" + wsPort;
      var wsUrl = "wss://" + wsHost + wsPort + "/" + wsPath;
      websocketConnection = new WebSocket(wsUrl);
      websocketConnection.addEventListener("message", onServerMessage);
    }
  </script>
</head>

<body>
  <div>
    <h1 class="text-center">Gstreamer Webrtc Camera</h1>
    <div class="text-center " id="container">
      <video class="w-75" id="video0" playsinline autoplay></video>
      <div class="text-center mb-5" id="loading" style="display:none">
        <div class="spinner-border" role="status">
          <span class="visually-hidden">Loading...</span>
        </div>
      </div>
      <div class="mt-3">
        <button type="button" class="btn btn-info" id="startWatch">Start</button>
        <button type="button" class="btn btn-light" id="startRecord">Start Record</button>
        <button type="button" class="btn btn-light" id="enableTalk">Talk on</button>
      </div>
    </div>
  </div>
</body>

</html>